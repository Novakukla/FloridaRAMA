<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --radius: 18px;
      --gap: 18px;
      --shadow: 0 12px 30px rgba(0,0,0,.18);
      --overlay-opacity: 0;
    }

    html, body { margin:0; padding:0; background:transparent; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    .wrap{
      width: 100%;
      box-sizing: border-box;
      padding: var(--gap);
      display: grid;
      gap: var(--gap);
    }

    .panel{
      position: relative;
      height: auto;
      aspect-ratio: var(--aspect, 16 / 9);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow);
      --reveal-y: 18px;
      --float-y: 0px;
      --hover-y: 0px;
      transform: translate3d(0, calc(var(--reveal-y) + var(--float-y) + var(--hover-y)), 0);
      opacity: 0;
      transition: transform 700ms ease, opacity 700ms ease;
      will-change: transform, opacity;
      background: transparent;
    }

    .panel.revealed{
      --reveal-y: 0px;
      opacity: 1;
    }

    /* The parallax layer (image) */
    .layer{
      position:absolute;
      inset: 0;
      will-change: transform;
      transform: translate3d(0,0,0);
    }
    .layer img{
      width:100%;
      height:100%;
      object-fit: contain;
      display:block;
      transform: translate3d(0,0,0);
      will-change: transform;
      user-select: none;
      pointer-events: none;
      background: transparent;
    }

    /* subtle readability overlay (optional) */
    .overlay{
      position:absolute;
      inset:0;
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,0.08),
        rgba(0,0,0,0.10) 35%,
        rgba(0,0,0,0.18)
      );
      opacity: var(--overlay-opacity);
      pointer-events:none;
    }

    /* last row split into 2 */
    .split{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
    }

    .panel.linklike { cursor: pointer; }

    /* optional hover polish (desktop only) */
    @media (hover:hover) and (pointer:fine){
      .panel.linklike:hover{
        --hover-y: -2px;
      }
    }

    @media (max-width: 820px){
      .wrap{ padding: 12px; gap: 12px; }
      .split{ grid-template-columns: 1fr; }
    }

    @media (prefers-reduced-motion: reduce){
      .panel{ transition: none; transform:none; opacity:1; }
      .layer{ inset:0; }
    }
  </style>
</head>

<body>
  <div class="wrap" id="wrap">

    <!-- Lucy -->
    <section class="panel linklike" style="--aspect: 16 / 9;" data-parallax="off" data-speed="0.22" data-href="/lucy-sparrow" aria-label="Lucy Sparrow">
      <div class="layer">
        <img alt="Lucy Sparrow banner"
          src="https://static.wixstatic.com/media/400eb0_26800487d5cd4a0c9638f4d4f409cb26~mv2.png">
      </div>
      <div class="overlay"></div>
    </section>

    <!-- HoliDAZE -->
    <section class="panel linklike" style="--aspect: 16 / 9;" data-parallax="off" data-speed="0.18" data-href="/holidaze" aria-label="HoliDAZE">
      <div class="layer">
        <img alt="HoliDAZE banner"
          src="https://static.wixstatic.com/media/400eb0_c58852815f8549ffaa247fb6da12a752~mv2.png">
      </div>
      <div class="overlay"></div>
    </section>

    <!-- Split row: Membership + Gift Box -->
    <div class="split">
      <section class="panel linklike" style="--aspect: 16 / 9;" data-parallax="off" data-speed="0.20" data-href="/membership" aria-label="Membership">
        <div class="layer">
          <img alt="Membership banner"
            src="https://static.wixstatic.com/media/400eb0_41b4f29a318543a4af2f1101d781e96b~mv2.png">
        </div>
        <div class="overlay"></div>
      </section>

      <section class="panel linklike" style="--aspect: 16 / 9;" data-parallax="off" data-speed="0.16" data-href="/gift-box" aria-label="Gift Box">
        <div class="layer">
          <img alt="Gift box banner"
            src="https://static.wixstatic.com/media/400eb0_a903ed97156c48cd9d4cd608c4f1c924~mv2.png">
        </div>
        <div class="overlay"></div>
      </section>
    </div>

  </div>

  <script>
    const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const panels = Array.from(document.querySelectorAll(".panel"));

    // Click-through (keeps Wix routing simple)
    function navigateTop(href) {
      if (!href) return;
      try {
        window.top.location.href = href;
      } catch {
        window.location.href = href;
      }
    }

    panels.forEach((panel) => {
      panel.setAttribute("tabindex", "0");
      panel.addEventListener("click", () => navigateTop(panel.getAttribute("data-href")));
      panel.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          navigateTop(panel.getAttribute("data-href"));
        }
      });
    });

    // Reveal: use IntersectionObserver when it makes sense, but also support
    // parent-page scrolling (Wix) by computing visibility using frame position.
    const revealed = new WeakSet();
    const io = ("IntersectionObserver" in window)
      ? new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("revealed");
              revealed.add(entry.target);
              io.unobserve(entry.target);
            }
          });
        }, { threshold: 0.12 })
      : null;

    if (io) panels.forEach((p) => io.observe(p));

    // Cache panel geometry so we don't read layout per-panel on every frame.
    let panelMetrics = [];
    function getScrollY() {
      return window.scrollY || document.documentElement.scrollTop || 0;
    }

    function recalcMetrics() {
      const scrollY = getScrollY();
      panelMetrics = panels.map((panel) => {
        const img = panel.querySelector(".layer img");
        const speed = parseFloat(panel.getAttribute("data-speed") || "0.18");
        const rect = panel.getBoundingClientRect();
        const height = rect.height;
        const topDoc = rect.top + scrollY;
        const midDoc = topDoc + height / 2;
        return { panel, img, speed, midDoc, height };
      });
    }
    recalcMetrics();

    // Auto-height: send only when changed, throttled.
    let lastSentHeight = -1;
    let heightRaf = 0;
    function sendHeight() {
      heightRaf = 0;
      const height = document.documentElement.scrollHeight;
      if (height === lastSentHeight) return;
      lastSentHeight = height;
      window.parent.postMessage({ type: "WIX_EMBED_HEIGHT", height }, "*");
    }
    function requestHeightSend() {
      if (heightRaf) return;
      heightRaf = requestAnimationFrame(sendHeight);
    }

    // Watch for content-size changes (images, responsive reflow, etc.)
    const ro = ("ResizeObserver" in window)
      ? new ResizeObserver(() => {
          recalcMetrics();
          requestHeightSend();
        })
      : null;

    if (ro) ro.observe(document.documentElement);
    window.addEventListener("resize", () => {
      recalcMetrics();
      requestHeightSend();
    }, { passive: true });

    // Synced parallax: base movement on the element's position in the *parent* viewport.
    // Key trick: the iframe itself moves on parent scroll; we can read its rect.
    function getParentViewportHeight() {
      try {
        return window.top.innerHeight || window.parent.innerHeight || window.innerHeight || 800;
      } catch {
        return window.innerHeight || 800;
      }
    }

    function getIframeTopInParentViewport() {
      try {
        const fe = window.frameElement;
        if (!fe || !fe.getBoundingClientRect) return 0;
        return fe.getBoundingClientRect().top;
      } catch {
        return 0;
      }
    }

    function maybeReveal(panelMidInParent, parentVh, panel) {
      if (revealed.has(panel)) return;
      // Trigger once when panel midpoint enters the viewport with a little pre-roll.
      const triggerTop = -0.10 * parentVh;
      const triggerBottom = 1.10 * parentVh;
      if (panelMidInParent >= triggerTop && panelMidInParent <= triggerBottom) {
        panel.classList.add("revealed");
        revealed.add(panel);
      }
    }

    let rafId = 0;
    function tick() {
      rafId = 0;

      requestHeightSend();
      if (reduceMotion) return;

      const parentVh = getParentViewportHeight();
      const iframeTop = getIframeTopInParentViewport();
      const viewportMid = parentVh / 2;
      const scrollY = getScrollY();

      for (const m of panelMetrics) {
        if (!m.img) continue;

        const parallaxMode = (m.panel.getAttribute("data-parallax") || "on").toLowerCase();
        const floatAmount = parseFloat(m.panel.getAttribute("data-float") || "10");

        // Convert cached document-space mid -> iframe viewport mid.
        // In Wix, the iframe itself moves within the parent viewport, so add iframeTop.
        const midInIframeViewport = m.midDoc - scrollY;
        const midInParentViewport = iframeTop + midInIframeViewport;

        maybeReveal(midInParentViewport, parentVh, m.panel);

        if (parallaxMode === "off" || parallaxMode === "none" || parallaxMode === "0") {
          // Keep full informational graphic visible: do NOT move the image.
          m.img.style.transform = "translate3d(0, 0px, 0)";

          // Scroll-linked motion without cropping: gently float the panel itself.
          // Negative moves up when centered; clamp keeps it subtle.
          const progress = (midInParentViewport - viewportMid) / viewportMid;
          const clamped = Math.max(-1, Math.min(1, progress));
          const y = Math.round(clamped * -floatAmount);
          m.panel.style.setProperty("--float-y", `${y}px`);
          continue;
        }

        // If using image parallax, avoid double motion.
        m.panel.style.setProperty("--float-y", "0px");

        // progress: -1 (above) to +1 (below)
        const progress = (midInParentViewport - viewportMid) / viewportMid;
        const clamped = Math.max(-1, Math.min(1, progress));
        const translateY = Math.round(clamped * m.speed * 140);
        m.img.style.transform = `translate3d(0, ${translateY}px, 0)`;
      }
    }

    function loop() {
      tick();
      requestAnimationFrame(loop);
    }

    // Start: don't block load; wait one frame.
    requestAnimationFrame(() => {
      // If reduced motion, reveal immediately and send height once.
      if (reduceMotion) {
        panels.forEach((p) => p.classList.add("revealed"));
        panels.forEach((p) => p.style.setProperty("--float-y", "0px"));
        requestHeightSend();
        return;
      }
      loop();
    });
  </script>
</body>
</html>
